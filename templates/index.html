<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Magic-Erasarr</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #181a24;
    --surface2: #1f2231;
    --border: #2a2d3e;
    --text: #e2e4ed;
    --text-dim: #8b8fa3;
    --accent: #6366f1;
    --accent-hover: #818cf8;
    --danger: #ef4444;
    --danger-hover: #f87171;
    --success: #22c55e;
    --warning: #f59e0b;
    --radius: 8px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 100;
  }

  header h1 {
    font-size: 1.25rem;
    font-weight: 600;
    letter-spacing: -0.02em;
  }

  header h1 span { color: var(--accent); }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1.5rem;
  }

  /* Toolbar */
  .toolbar {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 1.5rem;
  }

  select, input[type="text"] {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.5rem 0.75rem;
    font-size: 0.875rem;
    outline: none;
    transition: border-color 0.15s;
  }

  select:focus, input[type="text"]:focus {
    border-color: var(--accent);
  }

  select { min-width: 200px; cursor: pointer; }
  input[type="text"] { min-width: 220px; }
  .filter-label {
    font-size: 0.875rem;
    color: var(--text-dim);
    white-space: nowrap;
  }

  button {
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    border: none;
    border-radius: var(--radius);
    padding: 0.5rem 1rem;
    transition: background 0.15s, opacity 0.15s;
  }

  button:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-accent {
    background: var(--accent);
    color: #fff;
  }
  .btn-accent:hover:not(:disabled) { background: var(--accent-hover); }

  .btn-danger {
    background: var(--danger);
    color: #fff;
  }
  .btn-danger:hover:not(:disabled) { background: var(--danger-hover); }

  .btn-ghost {
    background: transparent;
    color: var(--text-dim);
    border: 1px solid var(--border);
  }
  .btn-ghost:hover:not(:disabled) {
    background: var(--surface2);
    color: var(--text);
  }

  /* Selection bar */
  .selection-bar {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.75rem 1rem;
    margin-bottom: 1rem;
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .selection-bar.visible { display: flex; }

  .selection-bar .count {
    font-size: 0.875rem;
    color: var(--text-dim);
  }
  .selection-bar .count strong { color: var(--text); }

  /* Table — variable width, wrap text so table fits; scroll horizontally when needed */
  .table-wrap {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow-x: auto;
    overflow-y: visible;
  }

  table {
    width: 100%;
    min-width: 600px;
    border-collapse: collapse;
    table-layout: auto;
  }

  thead th {
    text-align: left;
    padding: 0.75rem 1rem;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    background: var(--surface2);
    border-bottom: 1px solid var(--border);
    user-select: none;
    white-space: nowrap;
  }

  thead th.check-col { width: 40px; min-width: 40px; text-align: center; }

  thead th.sortable {
    cursor: pointer;
    position: relative;
    padding-right: 1.5rem;
  }

  thead th.sortable:hover { color: var(--text); }

  thead th.sortable::after {
    content: '⇅';
    position: absolute;
    right: 0.5rem;
    opacity: 0.3;
    font-size: 0.7rem;
  }

  thead th.sortable.sort-asc::after {
    content: '↑';
    opacity: 0.9;
  }

  thead th.sortable.sort-desc::after {
    content: '↓';
    opacity: 0.9;
  }

  tbody tr {
    border-bottom: 1px solid var(--border);
    transition: background 0.1s;
  }

  tbody tr:last-child { border-bottom: none; }
  tbody tr:hover { background: var(--surface2); }
  tbody tr.selected { background: rgba(99,102,241,0.08); }

  td {
    padding: 0.65rem 1rem;
    font-size: 0.875rem;
    vertical-align: middle;
    white-space: normal;
    word-break: break-word;
  }

  td.check-col { text-align: center; }
  td.cell-nowrap { white-space: nowrap; }

  td.title-cell {
    white-space: normal;
    min-width: 100px;
    max-width: 400px;
    font-weight: 500;
  }

  td.title-cell .year {
    color: var(--text-dim);
    font-weight: 400;
    margin-left: 0.35rem;
  }

  td.dim { color: var(--text-dim); }

  td.cell-library,
  td.cell-requested { min-width: 80px; max-width: 180px; }

  input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--accent);
    cursor: pointer;
  }

  /* Pagination */
  .pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 0;
    font-size: 0.8rem;
    color: var(--text-dim);
  }

  .pagination .page-btns { display: flex; gap: 0.5rem; }

  /* Status badge */
  .badge {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .badge-file { background: rgba(34,197,94,0.12); color: var(--success); }
  .badge-nofile { background: rgba(245,158,11,0.12); color: var(--warning); }

  .cell-loading {
    color: var(--text-dim);
    font-size: 0.75rem;
    font-style: italic;
  }

  /* Modal */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
  }

  .modal-overlay.visible { display: flex; }

  .modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.75rem;
    max-width: 480px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
  }

  .modal h2 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
  }

  .modal p {
    color: var(--text-dim);
    font-size: 0.875rem;
    line-height: 1.5;
    margin-bottom: 1.25rem;
  }

  .modal ul {
    list-style: none;
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 1.25rem;
    padding: 0.5rem;
    background: var(--bg);
    border-radius: var(--radius);
    font-size: 0.8125rem;
  }

  .modal ul li {
    padding: 0.3rem 0.5rem;
    border-bottom: 1px solid var(--border);
  }

  .modal ul li:last-child { border-bottom: none; }

  .modal-actions {
    display: flex;
    gap: 0.75rem;
    justify-content: flex-end;
  }

  /* Spinner */
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    vertical-align: middle;
    margin-right: 0.35rem;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  /* Footer */
  .app-footer {
    margin-top: 2rem;
    padding: 0.75rem 0;
    font-size: 0.8125rem;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
  }
  .app-footer-version { font-variant-numeric: tabular-nums; }
  .app-footer-link {
    color: var(--text-dim);
    text-decoration: none;
  }
  .app-footer-link:hover { color: var(--text); }

  /* Toast Overlay */
  .toast-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 999;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .toast-overlay.active {
    display: flex;
  }

  /* Toast */
  .toast-container {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 300;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .toast {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.75rem 1rem;
    font-size: 0.8125rem;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    animation: slideIn 0.25s ease-out;
    max-width: 360px;
  }

  /* Centered modal toast */
  .toast-overlay .toast {
    position: relative;
    max-width: 600px;
    width: 90%;
    font-size: 1.25rem;
    padding: 2rem;
    text-align: center;
    z-index: 1000;
    animation: fadeInScale 0.3s ease-out;
    line-height: 1.6;
    white-space: normal;
  }

  .toast.success { border-left: 3px solid var(--success); }
  .toast.error { border-left: 3px solid var(--danger); }
  .toast.info { border-left: 3px solid var(--accent); }

  @keyframes slideIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @keyframes fadeInScale {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
  }

  /* Flashing red warning text */
  .toast-warning-flash {
    color: var(--danger);
    font-weight: 600;
    animation: flashRed 1s ease-in-out infinite;
  }

  @keyframes flashRed {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Empty state */
  .empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--text-dim);
  }

  .empty-state p { font-size: 0.9375rem; }

  /* Loading overlay for table */
  .table-loading {
    text-align: center;
    padding: 2rem;
    color: var(--text-dim);
    font-size: 0.875rem;
  }

  /* Status bar */
  .status-bar {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .status-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.75rem;
    padding: 0.3rem 0.65rem;
    border-radius: 999px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
  }

  .status-chip .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }

  .status-chip .chip-text {
    display: flex;
    flex-direction: column;
    line-height: 1.2;
  }

  .status-chip .chip-version {
    font-size: 0.625rem;
    opacity: 0.6;
    font-weight: 400;
  }

  .status-chip.ok .dot { background: var(--success); }
  .status-chip.fail .dot { background: var(--danger); }
  .status-chip.checking .dot {
    background: var(--warning);
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Top alert banner (e.g. Tautulli calculating file sizes) */
  .top-alert {
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    padding: 0.75rem 1.5rem;
    background: rgba(245, 158, 11, 0.2);
    border-bottom: 1px solid var(--warning);
    color: var(--text);
    font-size: 0.9375rem;
    position: relative;
    z-index: 200;
  }

  .top-alert.visible {
    display: flex !important;
  }

  .top-alert-message {
    flex: 1;
  }

  .top-alert-dismiss {
    flex-shrink: 0;
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 0.35rem 0.75rem;
    border-radius: var(--radius);
    cursor: pointer;
    font-size: 0.8125rem;
  }

  .top-alert-dismiss:hover {
    color: var(--text);
    border-color: var(--text-dim);
  }
</style>
</head>
<body>

<header>
  <h1><span>Magic</span>-Erasarr</h1>
</header>

<div class="top-alert" id="topAlert">
  <span class="top-alert-message">Tautulli is calculating file sizes for the library's media info. Some data may be missing or delayed until the calculation completes.</span>
  <button type="button" class="top-alert-dismiss" id="topAlertDismiss">Dismiss</button>
</div>

<div class="container">
  <!-- Status chips (populated dynamically) -->
  <div class="status-bar" id="statusBar"></div>

  <!-- Toolbar -->
  <div class="toolbar">
    <select id="librarySelect">
      <option value="">Select type...</option>
      <option value="combined:movie">Movies</option>
      <option value="combined:show">TV Shows</option>
      <option value="combined:artist">Music</option>
    </select>
    <div class="search-wrap" id="libraryFilterWrap" style="display:none;">
      <label for="libraryFilter" class="filter-label">Filter by library:</label>
      <select id="libraryFilter">
        <option value="">All libraries</option>
      </select>
    </div>
    <div class="search-wrap" id="searchWrap" style="display:none;">
      <input type="text" id="searchInput" placeholder="Search titles..." />
    </div>
    <div class="search-wrap" id="requestorSearchWrap" style="display:none;">
      <input type="text" id="requestorSearchInput" placeholder="Requested by..." />
    </div>
    <button class="btn-accent" id="loadBtn" disabled>Load</button>
  </div>

  <!-- Selection bar -->
  <div class="selection-bar" id="selectionBar">
    <span class="count"><strong id="selCount">0</strong> item(s) selected</span>
    <div>
      <button class="btn-ghost" id="clearSelBtn">Clear Selection</button>
      <button class="btn-danger" id="removeBtn">Remove Selected</button>
    </div>
  </div>

  <!-- Table -->
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th class="check-col"><input type="checkbox" id="checkAll" title="Select all" /></th>
          <th class="sortable" data-sort="sort_title">Title</th>
          <th class="sortable" data-sort="year">Year</th>
          <th class="sortable" data-sort="added_at">Added</th>
          <th class="sortable sort-asc" data-sort="last_played">Last Played</th>
          <th class="sortable" data-sort="play_count">Play Count</th>
          <th>File</th>
          <th class="sortable" data-sort="file_size">Size</th>
          <th class="sortable" data-sort="library_name">Library</th>
          <th class="sortable" data-sort="requested_by">Requested By</th>
        </tr>
      </thead>
      <tbody id="mediaBody">
        <tr>
          <td colspan="10">
            <div class="empty-state"><p>Select a type (Movies, TV Shows, or Music) and click Load.</p></div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Pagination -->
  <div class="pagination" id="paginationBar" style="display:none;">
    <span id="pageInfo"></span>
    <div class="page-btns">
      <button class="btn-ghost" id="prevBtn" disabled>&laquo; Prev</button>
      <button class="btn-ghost" id="nextBtn" disabled>Next &raquo;</button>
    </div>
  </div>
</div>

<!-- Confirm modal -->
<div class="modal-overlay" id="confirmModal">
  <div class="modal">
    <h2>Confirm Removal</h2>
    <p>The following items will be <strong>removed from Seerr</strong> (request + data cleared), <strong>deleted from all configured Radarr/Sonarr instances</strong> (including files on disk), and <strong>purged from Tautulli</strong> (history + cache):</p>
    <ul id="confirmList"></ul>
    <div class="modal-actions">
      <button class="btn-ghost" id="cancelBtn">Cancel</button>
      <button class="btn-danger" id="confirmBtn">Remove</button>
    </div>
  </div>
</div>

<!-- Toasts -->
<div class="toast-container" id="toasts"></div>
<div class="toast-overlay" id="toastOverlay"></div>

<footer class="app-footer">
  <span class="app-footer-version">v{{ version }}</span>
  <a class="app-footer-link" href="{{ github_repo }}" target="_blank" rel="noopener noreferrer">GitHub</a>
</footer>

<script>
(function() {
  const PAGE_SIZE = 50;
  let currentLib = null;
  let currentLibType = null;
  let page = 0;
  let totalCount = 0;
  let selected = new Map();
  let statusKeys = [];
  let sortColumn = 'last_played';
  let sortDir = 'asc';
  let lastItems = [];
  let lastOsrInfo = null;
  let seerrDisplayName = 'Seerr';
  let libraryLoaded = false;

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => document.querySelectorAll(sel);

  // Parse response as JSON; if server returned HTML (error page), throw a clear error.
  async function parseJsonResponse(res) {
    const text = await res.text();
    const trimmed = text.trim();
    if (!trimmed || (trimmed[0] !== '{' && trimmed[0] !== '[')) {
      throw new Error('Server returned an error page instead of JSON. Try again or check the server logs.');
    }
    try {
      return JSON.parse(text);
    } catch (e) {
      throw new Error('Invalid JSON from server: ' + (e.message || String(e)));
    }
  }

  // --- Toast ---
  function toast(msg, type = 'info') {
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.textContent = msg;
    $('#toasts').appendChild(el);
    setTimeout(() => el.remove(), 4500);
  }

  // --- Status chips (initial labels are placeholders; real names come from /api/status) ---
  async function initStatusBar() {
    const bar = $('#statusBar');
    const chips = [
      { key: 'tautulli', label: '…' },
      { key: 'overseerr', label: '…' },
    ];
    try {
      const res = await fetch('/api/instances');
      const inst = await parseJsonResponse(res);
      for (const r of (inst.radarr || [])) chips.push({ key: r.key, label: r.name });
      for (const s of (inst.sonarr || [])) chips.push({ key: s.key, label: s.name });
      for (const l of (inst.lidarr || [])) chips.push({ key: l.key, label: l.name });
    } catch {}

    statusKeys = chips.map(c => c.key);
    bar.innerHTML = chips.map(c =>
      `<div class="status-chip checking" id="st-${c.key}"><span class="dot"></span> <span class="chip-text"><span class="chip-label">${c.label}</span></span></div>`
    ).join('');
  }

  async function checkStatus() {
    try {
      const res = await fetch('/api/status');
      const data = await parseJsonResponse(res);
      for (const key of statusKeys) {
        const chip = $(`#st-${key}`);
        if (!chip) continue;
        chip.classList.remove('checking');
        const val = data[key];
        if (val && typeof val === 'object' && val.status === 'ok') {
          chip.classList.add('ok');
          if (val.name) {
            const labelEl = chip.querySelector('.chip-label');
            if (labelEl) labelEl.textContent = val.name;
            if (key === 'overseerr') seerrDisplayName = val.name;
          }
          if (val.version) {
            const textEl = chip.querySelector('.chip-text');
            const ver = document.createElement('span');
            ver.className = 'chip-version';
            ver.textContent = 'v' + val.version;
            textEl.appendChild(ver);
          }
        } else if (val) {
          chip.classList.add('fail');
          chip.title = typeof val === 'string' ? val : JSON.stringify(val);
        } else {
          chip.classList.add('fail');
          chip.title = 'not configured';
        }
      }
    } catch {
      for (const key of statusKeys) {
        const chip = $(`#st-${key}`);
        if (!chip) continue;
        chip.classList.remove('checking');
        chip.classList.add('fail');
      }
    }
  }

  // --- Libraries: dropdown is static (Movies / TV Shows / Music) ---
  function loadLibraries() {
    // Options are in HTML; just ensure load btn state
    $('#loadBtn').disabled = !$('#librarySelect').value;
  }

  // --- Media ---
  function renderTable(items, overseerrInfo) {
    const body = $('#mediaBody');
    body.innerHTML = items.map(item => {
      const rk = item.rating_key;
      const isChecked = selected.has(String(rk)) ? 'checked' : '';
      const selClass = isChecked ? 'selected' : '';
      const lastPlayed = item.last_played
        ? new Date(item.last_played * 1000).toLocaleDateString()
        : 'Never';
      const addedAt = item.added_at
        ? new Date(item.added_at * 1000).toLocaleDateString()
        : '—';
      // Tautulli: movies use file_size; shows often have no file_size until media info cache is refreshed
      const rawSize = getFileSize(item);
      const fileSize = rawSize > 0 ? formatBytes(rawSize) : '—';
      let fileBadge;
      if (rawSize > 0) {
        fileBadge = '<span class="badge badge-file">On Disk</span>';
      } else if (currentLibType === 'artist' || currentLibType === 'show') {
        // Artist: no file concept. Show: Tautulli rarely has file_size at show level (only after cache refresh)
        fileBadge = '<span class="dim">—</span>';
      } else {
        fileBadge = '<span class="badge badge-nofile">Missing</span>';
      }

      const osr = overseerrInfo ? overseerrInfo[rk] : null;
      let reqByHtml;
      if (currentLibType === 'artist') {
        reqByHtml = '<span class="dim">—</span>';
      } else if (overseerrInfo) {
        reqByHtml = (osr && osr.requested_by) ? esc(osr.requested_by) : '<span class="dim">—</span>';
      } else {
        reqByHtml = '<span class="cell-loading">loading...</span>';
      }
      const libraryName = item.library_name != null ? esc(item.library_name) : '—';
      const sectionId = item.section_id != null ? esc(String(item.section_id)) : '';
      const itemGuid = (item.guid != null && item.guid !== '') ? String(item.guid) : '';

      return `<tr class="${selClass}" data-rk="${rk}" data-section-id="${sectionId}" data-guid="${esc(itemGuid)}">
        <td class="check-col"><input type="checkbox" class="row-check" data-rk="${rk}" data-title="${esc(item.title)}" data-year="${item.year || ''}" data-guid="${esc(itemGuid)}" ${isChecked} /></td>
        <td class="title-cell">${esc(item.title)}<span class="year">${item.year ? '(' + item.year + ')' : ''}</span></td>
        <td class="dim cell-nowrap">${item.year || '—'}</td>
        <td class="dim cell-nowrap">${addedAt}</td>
        <td class="dim cell-nowrap">${lastPlayed}</td>
        <td class="dim cell-nowrap">${item.play_count || 0}</td>
        <td class="cell-nowrap">${fileBadge}</td>
        <td class="dim cell-nowrap">${fileSize}</td>
        <td class="dim cell-library">${libraryName}</td>
        <td class="dim cell-requested">${reqByHtml}</td>
      </tr>`;
    }).join('');
  }

  function updateSortHeaders() {
    $$('thead th.sortable').forEach(th => {
      th.classList.remove('sort-asc', 'sort-desc');
      if (th.dataset.sort === sortColumn) {
        th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
      }
    });
  }

  function sortItemsByRequestedBy(items, osrInfo, dir) {
    if (!osrInfo) return items;
    return [...items].sort((a, b) => {
      const aReq = (osrInfo[a.rating_key] && osrInfo[a.rating_key].requested_by) || '';
      const bReq = (osrInfo[b.rating_key] && osrInfo[b.rating_key].requested_by) || '';
      const cmp = aReq.localeCompare(bReq);
      return dir === 'asc' ? cmp : -cmp;
    });
  }

  async function loadMedia() {
    if (!currentLib) return;
    const body = $('#mediaBody');
    body.innerHTML = '<tr><td colspan="10"><div class="table-loading"><span class="spinner"></span> Loading...</div></td></tr>';
    try {
      const search = $('#searchInput').value.trim();
      const requestorSearch = $('#requestorSearchInput').value.trim();
      const isClientSort = sortColumn === 'requested_by';
      const apiSortCol = isClientSort ? 'last_played' : sortColumn;
      const apiSortDir = isClientSort ? 'asc' : sortDir;
      const isCombined = currentLib.startsWith('combined:');
      const typeParam = isCombined ? currentLib.replace('combined:', '') : '';
      const libraryFilter = $('#libraryFilter').value.trim();
      let url;
      if (isCombined) {
        url = `/api/library/combined?type=${encodeURIComponent(typeParam)}&length=${PAGE_SIZE}&start=${page * PAGE_SIZE}&order_column=${apiSortCol}&order_dir=${apiSortDir}`;
        if (libraryFilter) url += `&library_name=${encodeURIComponent(libraryFilter)}`;
        if (search) url += `&search=${encodeURIComponent(search)}`;
        // Optional: ?test_calculating=1 in page URL forces the "calculating file sizes" banner for testing
        if (new URLSearchParams(window.location.search).get('test_calculating') === '1') url += '&show_calculating_alert=1';
      } else {
        url = `/api/library/${currentLib}?length=${PAGE_SIZE}&start=${page * PAGE_SIZE}&order_column=${apiSortCol}&order_dir=${apiSortDir}`;
        if (search) url += `&search=${encodeURIComponent(search)}`;
      }
      const res = await fetch(url);
      const data = await parseJsonResponse(res);
      if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
      if (data.error) throw new Error(data.error);

      const items = data.data || [];
      totalCount = data.recordsFiltered != null ? data.recordsFiltered : (data.recordsTotal != null ? data.recordsTotal : items.length);
      if (data.section_type) currentLibType = data.section_type;

      // Show or hide top alert when Tautulli is calculating file sizes
      const topAlert = document.getElementById('topAlert');
      if (topAlert) {
        if (data.tautulli_calculating_file_sizes === true) {
          topAlert.classList.add('visible');
        } else {
          topAlert.classList.remove('visible');
        }
      }

      if (isCombined && data.libraries && Array.isArray(data.libraries)) {
        const filterSel = $('#libraryFilter');
        const currentVal = filterSel.value;
        filterSel.innerHTML = '<option value="">All libraries</option>' +
          data.libraries.map(l => {
            const safe = (l || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;');
            return `<option value="${safe}">${esc(l)}</option>`;
          }).join('');
        if (currentVal && data.libraries.some(l => (l || '').trim() === currentVal)) filterSel.value = currentVal;
        $('#libraryFilterWrap').style.display = '';
      } else {
        $('#libraryFilterWrap').style.display = 'none';
      }

      if (!items.length) {
        body.innerHTML = '<tr><td colspan="10"><div class="empty-state"><p>No items found.</p></div></td></tr>';
        $('#paginationBar').style.display = 'none';
        libraryLoaded = true;
        $('#searchWrap').style.display = '';
        return;
      }

      libraryLoaded = true;
      $('#searchWrap').style.display = '';
      lastItems = items;
      lastOsrInfo = null;
      updateSortHeaders();

      renderTable(items, null);

      const totalPages = Math.ceil(totalCount / PAGE_SIZE);
      $('#pageInfo').textContent = `Page ${page + 1} of ${totalPages} (${totalCount} items)`;
      $('#prevBtn').disabled = page === 0;
      $('#nextBtn').disabled = page + 1 >= totalPages;
      $('#paginationBar').style.display = 'flex';

      updateSelectionBar();

      // Fetch Seerr requestor info (skip for artist libraries); then show Requested by search box
      if (currentLibType === 'artist') {
        lastOsrInfo = {};
        renderTable(items, {});
      } else {
        const ratingKeys = items.map(i => String(i.rating_key));
        try {
          const osrRes = await fetch('/api/overseerr-info', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              rating_keys: ratingKeys,
              media_type: currentLibType || 'movie',
            }),
          });
          const osrInfo = await parseJsonResponse(osrRes);
          lastOsrInfo = osrInfo;
          let displayItems = isClientSort
            ? sortItemsByRequestedBy(items, osrInfo, sortDir)
            : items;
          // Client-side filter by Requested by (avoids slow backend timeout)
          if (requestorSearch) {
            const rq = requestorSearch.toLowerCase();
            displayItems = displayItems.filter(it => {
              const rb = (osrInfo[String(it.rating_key)] || {}).requested_by || '';
              return rb.toLowerCase().includes(rq);
            });
            totalCount = displayItems.length;
            $('#pageInfo').textContent = `Requested by "${requestorSearch}": ${displayItems.length} match(es) on this page`;
            $('#paginationBar').style.display = 'none';
          }
          renderTable(displayItems, osrInfo);
          updateSelectionBar();
          $('#requestorSearchWrap').style.display = '';
        } catch {
          lastOsrInfo = {};
          renderTable(items, {});
        }
      }
    } catch (e) {
      body.innerHTML = `<tr><td colspan="10"><div class="empty-state"><p>Error: ${esc(e.message)}</p></div></td></tr>`;
      toast('Failed to load media: ' + e.message, 'error');
    }
  }

  // --- Selection ---
  function updateSelectionBar() {
    const bar = $('#selectionBar');
    const n = selected.size;
    if (n > 0) {
      bar.classList.add('visible');
      $('#selCount').textContent = n;
    } else {
      bar.classList.remove('visible');
    }
    $('#checkAll').checked = false;
  }

  // --- Remove flow ---
  async function removeSelected() {
    const list = $('#confirmList');
    list.innerHTML = '';
    for (const [rk, info] of selected) {
      const li = document.createElement('li');
      li.textContent = `${info.title}${info.year ? ' (' + info.year + ')' : ''}`;
      list.appendChild(li);
    }
    $('#confirmModal').classList.add('visible');
  }

  async function confirmRemove() {
    const btn = $('#confirmBtn');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span> Removing...';

    const totalItems = selected.size;
    let successCount = 0;
    let failCount = 0;
    const sectionsToRefresh = new Map(); // Map<section_id, section_type>
    const removedServices = new Set();

    // Create overlay and persistent toast that updates throughout the entire flow
    const overlay = $('#toastOverlay');
    overlay.classList.add('active');
    const statusToastEl = document.createElement('div');
    statusToastEl.className = 'toast info';
    statusToastEl.textContent = `Removing ${totalItems} item${totalItems > 1 ? 's' : ''}...`;
    overlay.appendChild(statusToastEl);

    let processedCount = 0;
    for (const [rk, info] of selected) {
      processedCount++;
      statusToastEl.textContent = `Removing ${totalItems} item${totalItems > 1 ? 's' : ''}... (${processedCount}/${totalItems})`;
      try {
        const payload = {
          rating_key: rk,
          section_id: info.section_id != null ? info.section_id : currentLib,
          media_type: currentLibType,
        };
        if (info.guid) payload.guid = info.guid;
        if (info.title) payload.title = info.title;
        if (info.year != null && info.year !== '') payload.year = info.year;
        else {
          try {
            const idRes = await fetch('/api/item-ids?rating_key=' + encodeURIComponent(rk));
            const idData = await parseJsonResponse(idRes);
            if (idData && !idData.error && idData.guid) payload.guid = idData.guid;
            else if (idData && !idData.error) {
              if (idData.tmdb_id) payload.tmdb_id = idData.tmdb_id;
              if (idData.imdb_id) payload.imdb_id = idData.imdb_id;
              if (idData.tvdb_id) payload.tvdb_id = idData.tvdb_id;
              if (idData.mbid) payload.mbid = idData.mbid;
            }
          } catch (_) { /* keep payload as is */ }
        }
        const res = await fetch('/api/remove', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await parseJsonResponse(res);
        if (data.error) {
          console.error('Remove failed:', info.title, data);
          failCount++;
        } else {
          const parts = [];
          let hasArrRemoval = false;
          for (const [k, v] of Object.entries(data)) {
            if (typeof v === 'string' && v.startsWith('removed')) {
              parts.push(k);
              removedServices.add(k);
              // Check if this is an *arr removal (not Overseerr)
              if (k.startsWith('radarr_') || k.startsWith('sonarr_') || k.startsWith('lidarr_')) {
                hasArrRemoval = true;
              }
            }
          }
          // Track section_id and section_type for Plex/Tautulli refresh if any *arr deletion succeeded
          const sectionId = data._section_id_for_refresh || (hasArrRemoval && payload.section_id ? payload.section_id : null);
          if (sectionId) {
            // Map media_type to section_type (they're the same: movie/show/artist)
            const sectionType = payload.media_type || currentLibType;
            sectionsToRefresh.set(sectionId, sectionType);
          }
          if (parts.length) {
            successCount++;
          }
          selected.delete(rk);
        }
      } catch (e) {
        failCount++;
        console.error('Error removing:', info.title, e);
      }
    }

    // Update toast after all items processed
    const serviceLabels = Array.from(removedServices).map(p => {
      if (p === 'overseerr') return seerrDisplayName;
      if (p.startsWith('radarr_')) return p.replace('radarr_', 'Radarr ');
      if (p.startsWith('sonarr_')) return p.replace('sonarr_', 'Sonarr ');
      if (p.startsWith('lidarr_')) return p.replace('lidarr_', 'Lidarr ');
      return p;
    });
    const serviceSummary = serviceLabels.length > 0 ? ` from ${serviceLabels.join(' & ')}` : '';

    if (failCount === 0 && successCount > 0) {
      statusToastEl.className = 'toast success';
      statusToastEl.textContent = `Removed ${successCount} item${successCount > 1 ? 's' : ''}${serviceSummary}`;
    } else if (successCount > 0) {
      statusToastEl.className = 'toast info';
      statusToastEl.textContent = `Removed ${successCount} item${successCount > 1 ? 's' : ''}${serviceSummary}, ${failCount} failed`;
    } else {
      statusToastEl.className = 'toast error';
      statusToastEl.textContent = `Failed to remove ${failCount} item${failCount > 1 ? 's' : ''}`;
    }

    // Refresh Plex libraries for sections that had successful *arr deletions
    console.log('Sections to refresh:', Array.from(sectionsToRefresh.entries()), 'Removed services:', Array.from(removedServices));
    if (sectionsToRefresh.size > 0) {
      const sectionsArray = Array.from(sectionsToRefresh.entries()).map(([section_id, section_type]) => ({
        section_id,
        section_type
      }));
      
      // Step 1: Refresh Plex libraries
      const prevMsg = statusToastEl.textContent;
      statusToastEl.className = 'toast info';
      statusToastEl.textContent = `${prevMsg} Refreshing ${sectionsToRefresh.size} Plex library/libraries...`;
      
      try {
        const refreshRes = await fetch('/api/refresh-plex', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ section_ids: sectionsArray.map(s => s.section_id) }),
        });
        const refreshData = await parseJsonResponse(refreshRes);
        if (refreshData.refreshed && refreshData.refreshed.length > 0) {
          const plexSuccessMsg = `${prevMsg} Refreshed ${refreshData.refreshed.length} Plex library/libraries`;
          statusToastEl.textContent = plexSuccessMsg;
          
          // Step 2: Wait 20 seconds before refreshing Tautulli media info
          let countdown = 20;
          statusToastEl.textContent = `${plexSuccessMsg} Waiting ${countdown}s before refreshing Tautulli...`;
          
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              statusToastEl.textContent = `${plexSuccessMsg} Waiting ${countdown}s before refreshing Tautulli...`;
            } else {
              clearInterval(countdownInterval);
              statusToastEl.textContent = `${plexSuccessMsg} Refreshing Tautulli media info...`;
              
              // Trigger Tautulli refresh
              fetch('/api/refresh-tautulli', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sections: sectionsArray }),
              })
                .then(res => parseJsonResponse(res))
                .then(tautulliData => {
                  if (tautulliData.refreshed && tautulliData.refreshed.length > 0) {
                    // Check if any sections are TV shows
                    const hasTVShows = sectionsArray.some(s => s.section_type === 'show');
                    
                    if (hasTVShows) {
                      // Show warning for TV shows before reloading
                      statusToastEl.className = 'toast success';
                      const warningSpan = document.createElement('span');
                      warningSpan.className = 'toast-warning-flash';
                      warningSpan.textContent = ' ⚠️ WARNING: TV show removal may take several minutes to appear in Tautulli as it rescans the entire library and all episodes.';
                      statusToastEl.innerHTML = `${prevMsg} Refreshed ${refreshData.refreshed.length} Plex library/libraries & Tautulli media info.`;
                      statusToastEl.appendChild(document.createElement('br'));
                      statusToastEl.appendChild(warningSpan);
                      statusToastEl.appendChild(document.createElement('br'));
                      const reloadSpan = document.createElement('span');
                      reloadSpan.textContent = 'Reloading...';
                      statusToastEl.appendChild(reloadSpan);
                      
                      // Reload page after showing warning for 5 seconds
                      setTimeout(() => {
                        overlay.classList.remove('active');
                        window.location.reload();
                      }, 5000);
                    } else {
                      statusToastEl.className = 'toast success';
                      statusToastEl.textContent = `${prevMsg} Refreshed ${refreshData.refreshed.length} Plex library/libraries & Tautulli media info. Reloading...`;
                      // Reload page to show updated library
                      setTimeout(() => {
                        overlay.classList.remove('active');
                        window.location.reload();
                      }, 1000);
                    }
                  } else {
                    statusToastEl.className = 'toast info';
                    statusToastEl.textContent = `${prevMsg} Refreshed ${refreshData.refreshed.length} Plex library/libraries (Tautulli refresh had errors)`;
                    setTimeout(() => {
                      overlay.classList.remove('active');
                      statusToastEl.remove();
                    }, 5000);
                  }
                })
                .catch(e => {
                  statusToastEl.className = 'toast info';
                  statusToastEl.textContent = `${prevMsg} Refreshed ${refreshData.refreshed.length} Plex library/libraries (Tautulli refresh failed: ${e.message})`;
                  setTimeout(() => {
                    overlay.classList.remove('active');
                    statusToastEl.remove();
                  }, 5000);
                  console.error('Tautulli refresh failed:', e);
                });
            }
          }, 1000);
        } else {
          statusToastEl.className = 'toast error';
          statusToastEl.textContent = `${prevMsg} Plex refresh completed with errors`;
          setTimeout(() => {
            overlay.classList.remove('active');
            statusToastEl.remove();
          }, 5000);
        }
      } catch (e) {
        statusToastEl.className = 'toast error';
        statusToastEl.textContent = `${prevMsg} Plex refresh failed: ${e.message}`;
        setTimeout(() => {
          overlay.classList.remove('active');
          statusToastEl.remove();
        }, 5000);
        console.error('Plex refresh failed:', e);
      }
    } else {
      // No Plex refresh needed, remove toast after a delay
      setTimeout(() => {
        overlay.classList.remove('active');
        statusToastEl.remove();
      }, 5000);
    }

    btn.disabled = false;
    btn.textContent = 'Remove';
    $('#confirmModal').classList.remove('visible');
    updateSelectionBar();

    if (successCount > 0) loadMedia();
  }

  // --- Helpers ---
  function getFileSize(item) {
    if (!item) return 0;
    const keys = ['file_size', 'total_file_size', 'size', 'total_size'];
    for (const k of keys) {
      const v = item[k];
      if (v != null && v !== '') {
        const n = Number(v);
        if (!Number.isNaN(n) && n > 0) return n;
      }
    }
    return 0;
  }
  function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  function esc(s) {
    const d = document.createElement('div');
    d.textContent = s || '';
    return d.innerHTML;
  }

  // --- Events ---
  $('#librarySelect').addEventListener('change', function() {
    currentLib = this.value || null;
    currentLibType = currentLib && currentLib.startsWith('combined:') ? currentLib.replace('combined:', '') : (currentLib ? 'movie' : null);
    $('#loadBtn').disabled = !currentLib;
    libraryLoaded = false;
    $('#libraryFilter').value = '';
    $('#libraryFilterWrap').style.display = 'none';
    $('#searchWrap').style.display = 'none';
    $('#searchInput').value = '';
    $('#requestorSearchWrap').style.display = 'none';
    $('#requestorSearchInput').value = '';
  });

  $('#libraryFilter').addEventListener('change', function() {
    if (libraryLoaded && currentLib) {
      page = 0;
      loadMedia();
    }
  });

  $('#loadBtn').addEventListener('click', () => {
    page = 0;
    sortColumn = 'last_played';
    sortDir = 'asc';
    selected.clear();
    lastItems = [];
    lastOsrInfo = null;
    updateSelectionBar();
    updateSortHeaders();
    loadMedia();
  });

  $('#searchInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && currentLib) {
      page = 0;
      loadMedia();
    }
  });
  $('#requestorSearchInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && currentLib) {
      page = 0;
      loadMedia();
    }
  });

  $('#prevBtn').addEventListener('click', () => { if (page > 0) { page--; loadMedia(); } });
  $('#nextBtn').addEventListener('click', () => { page++; loadMedia(); });

  document.addEventListener('change', (e) => {
    if (e.target.classList.contains('row-check')) {
      const rk = e.target.dataset.rk;
      const row = e.target.closest('tr');
      const sectionId = row && row.dataset.sectionId !== undefined ? row.dataset.sectionId : currentLib;
      const guid = (row && row.dataset.guid) || e.target.dataset.guid || '';
      if (e.target.checked) {
        selected.set(rk, {
          title: e.target.dataset.title,
          year: e.target.dataset.year,
          section_id: sectionId || currentLib,
          guid: guid || undefined,
        });
        row.classList.add('selected');
      } else {
        selected.delete(rk);
        row.classList.remove('selected');
      }
      updateSelectionBar();
    }
  });

  $('#checkAll').addEventListener('change', function() {
    $$('.row-check').forEach(cb => {
      cb.checked = this.checked;
      const rk = cb.dataset.rk;
      const row = cb.closest('tr');
      const sectionId = row && row.dataset.sectionId !== undefined ? row.dataset.sectionId : currentLib;
      const guid = (row && row.dataset.guid) || cb.dataset.guid || '';
      if (this.checked) {
        selected.set(rk, { title: cb.dataset.title, year: cb.dataset.year, section_id: sectionId || currentLib, guid: guid || undefined });
        row.classList.add('selected');
      } else {
        selected.delete(rk);
        row.classList.remove('selected');
      }
    });
    updateSelectionBar();
  });

  $('#clearSelBtn').addEventListener('click', () => {
    selected.clear();
    $$('.row-check').forEach(cb => { cb.checked = false; cb.closest('tr').classList.remove('selected'); });
    updateSelectionBar();
  });

  // --- Column sorting ---
  $$('thead th.sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = th.dataset.sort;
      if (col === sortColumn) {
        sortDir = sortDir === 'asc' ? 'desc' : 'asc';
      } else {
        sortColumn = col;
        sortDir = 'asc';
      }

      // "Requested By" is client-side only — re-sort cached data
      if (col === 'requested_by' && lastItems.length && lastOsrInfo) {
        updateSortHeaders();
        const sorted = sortItemsByRequestedBy(lastItems, lastOsrInfo, sortDir);
        renderTable(sorted, lastOsrInfo);
        updateSelectionBar();
        return;
      }

      page = 0;
      loadMedia();
    });
  });

  $('#removeBtn').addEventListener('click', removeSelected);
  $('#cancelBtn').addEventListener('click', () => $('#confirmModal').classList.remove('visible'));
  $('#confirmBtn').addEventListener('click', confirmRemove);

  $('#topAlertDismiss').addEventListener('click', () => $('#topAlert').classList.remove('visible'));

  $('#confirmModal').addEventListener('click', (e) => {
    if (e.target === $('#confirmModal')) $('#confirmModal').classList.remove('visible');
  });

  // Init
  (async () => {
    await initStatusBar();
    checkStatus();
    loadLibraries();
  })();
})();
</script>
</body>
</html>
